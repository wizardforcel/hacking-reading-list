# 三、格式化字符串漏洞

格式化字符串漏洞的通常分类是“通道问题”。如果二类不同的信息通道混合为一个，并且特殊的转义字符或序列用于分辨当前哪个通道是激活的，这一类型的漏洞就可能出现。多数情况下，通道之一是数据通道，它不会解析，只会复制，而另一个通道是控制通道。

虽然对于其本身来说并不是件坏事，如果攻击者能够提供用于某个通道的输入，它可能很快成为严重的安全问题。通常存在错误的转义，或者反转义的途径，或者忽视了某个层面，就像格式化字符串漏洞中那样。所以我们总结一下：通道问题本身没有任何漏洞，但是它们使得 bug 可以利用。

为了展示它背后的普遍问题，这里是一个常见通道问题的列表：

| 场景 | 数据通道 | 控制通道 | 安全问题 |
| --- | --- | --- | --- |
| 电话系统 | 声音或数据 | 控制音调 | 线路控制 |
| PPP 协议 | 传输数据 | PPP 命令 | 流量放大 |
| 栈 | 栈数据 | 返回地址 | 返回地址控制 |
| Malloc 缓冲区 | Malloc 数据 | 管理信息 | 内存写入 |
| 格式化字符串 | 输出字符串 | 格式化参数 | 格式化函数控制 |

回到特定的格式化字符串漏洞，有两种典型的场景，其中产生了格式化字符串漏洞。

第一类（Linux rpc.statd 和 IRIX telnetd 中）。漏洞存在于`syslog`的第二个参数中。格式化字符串部分是用户提供。

```c
char tmpbuf[512];

snprintf (tmpbuf, sizeof (tmpbuf), "foo: %s", user); 
tmpbuf[sizeof (tmpbuf) - 1] = ’\0’; 
syslog (LOG_NOTICE, tmpbuf);
```

第二类（wu-ftpd 和 Qualcomm Popper QPOP 2.53 中）。部分由用户提供的字符串简介传给了格式化函数。

```c
int Error (char *fmt, ...);

... 
int someotherfunc (char *user) { 
    ...
    Error (user); 
    ...
} 
...
```

虽然第一类漏洞能够由自动化工具安全监测（例如 pscan 或 TESOgcc），只有工具被告知函数`Error`用作格式化函数，第二类漏洞才能检测出来。

> 但是，你可以自动化识别源码中的额外格式化函数，以及它们的参数的过程，所以总之，寻找格式化字符串的过程可以完全自动化。你甚至可以归纳出，如果有这样的工具来完成这件事，并且它没有在你的源码中发现格式化字符串漏洞，你的源码就没有这类漏洞。这不同于缓冲区溢出漏洞，其中即使由资深审计者手动审计了源码，还是会错过漏洞，并且没有可靠的方式来自动化找出它们。

## 3.1 我们能够控制什么？

通过提供格式化字符串，我们就能够控制格式化函数的行为。我们现在需要检验我们具体能够控制什么，以及如何使用它来扩展这个对进程的部分控制，来完全控制执行流。

## 3.2 使程序崩溃

使用格式化字符串漏洞的简单攻击，就是使进程崩溃。这对于某些事情是实用的，例如使守护进程崩溃，它会转储核心，并且在核心转储中有一些有用的数据。或者在一些网络攻击中，让一个服务无法响应十分有用，例如 DNS 伪造。

但是，在使其崩溃中有一些趣味。几乎所有 UNIX 系统中，内核都会检测非法指针访问，并且进程会接收到`SIGSEGV`信号。通常程序会终止并转储核心。

通过利用格式化字符串，我们可以轻易触发一些无效指针访问，通过仅仅提供像这样的格式化字符串：

```c
printf ("%s%s%s%s%s%s%s%s%s%s%s%s");
```

由于`%s`展示某个地址中的内存，这个地址位于栈上，栈上也储存了大量其他数据。我们就有很大机会来从非法地址服务数据，这个地址并没有映射。同时，多数何世华函数的实现提供了`%n`参数的功能，他可以用于向栈上的地址写入。如果它执行了几次，也一定会产生崩溃。

## 3.3 查看进程内存

入股哦我们可以查看格式户函数的回复 -- 也就是输出字符串 -- 我们就可以从中收集有用信息，因为它是我们所控制的行为的输出。而且我们可以使用这个结果，来获得我们的客户端字符串做了什么，以及进程的布局是什么样的概览。

这对于很多东西都很使用，例如为真正的利用寻找正确的偏移，或者仅仅是重新构造目标进程栈帧。

### 3.3.1 查看栈

我们可以展示栈内存的一些部分，通过像这样使用格式化字符串：

```c
printf ("%08x.%08x.%08x.%08x.%08x\n");
```

这可以工作，因为我们让`printf`函数来从栈中获取五个参数，并将其展示为 8 位填充的十六进制数值。所以可能的输出是：

```
40012980.080628c4.bffff7a4.00000005.08059c04
```

这是栈内存的部分转储，从当前的栈底一直到栈顶 -- 假设栈向低地址增长。取决于格式化字符传缓冲区的大小，以及输出缓冲区的大小，使用这种技巧，你可以或多或少重构栈内存的一部分。在一些情况下，你甚至可以获取整个栈内存。

栈的转储提供了关于程序流以及函数局部变量的重要信息，并且可能对于寻找正确偏移以便成功利用有所帮助。

### 3.3.2 查看任何地址的内存

我们也可以查看不同于栈内存的任意地址。为此，我们需要让格式化函数从我们可以提供的某个地址展示内存。这就有两个问题：首先，我们需要找到一个格式化字符串，它将某个地址（传值）用作栈的参数，并且展示其中的内存，并且我们需要提供这个地址，我们在第一种情况中足够幸运，由于`%s`参数就是干这个的，它展示内存 -- 通常是 ASCIIZ 字符串 -- 从栈上提供的地址。所以剩下的问题是，如何将这个栈上的地址放到正确的位置上。

我们的格式化字符串通常位于栈上，所以我们已经距离完全控制这个区域非常进了，格式化字符串就在这里。格式化函数在内部维护一个指针，指向当前格式化参数的展区与。如果我们能够将这个指针指向一块可控的内存区域，我们就能向`%s`参数提供一个地址。为了修改栈指针，我们可以仅仅使用假的参数，它会通过打印垃圾来挖掘栈区。

> 这里我们假设我们能够完全控制整个字符串。我们稍后会看到，部分控制，字符串过滤，空字节包含的地址，以及类似的问题都会存在，无论何时利用字符串格式化漏洞。

```c
printf ("AAA0AAA1_%08x.%08x.%08x.%08x.%08x");
```

`%08x` 参数使格式化函数内部的栈指针向栈顶方向增加。将这个参数增加之后，栈指针就指向了我们的内存：格式化字符串本身。格式化函数总是维护最低的栈帧，所以如果我们的缓冲区完全在栈上，它一定会在当前栈指针的上面。如果我们正确选择了`%08x`的数值，我们就能够展示任意地址的内存，通过向我们的字符串附加`%s`。在我们的例子中，地址是非法的，它是`AAA0`。让我们将其换成真实的地址。

例如：

```c
address = 0x08480110 
// address (encoded as 32 bit le string): "\x10\x01\x48\x08"
printf ("\x10\x01\x48\x08_%08x.%08x.%08x.%08x.%08x|%s|");
```

就会转储`0x08480110`的内存，直到到达了空字符。通过动态增加内存地址，我们可以查看整个进程空间。甚至可以创建远程进程的核心转储，就像映像那样，以及从中重新构建二进制。寻找利用不成功的原因也是很有用的。

如果我们不能通过使用 4 字节的 POP 来达到精确的格式化字符串的边界，我们需要填充格式化字符串，通过前置一个、两个或三个垃圾字符。这就好比缓冲区溢出利用中的对齐。

> 我们不能够按位移动栈指针，反之我们移动格式化字符串本身，以便到达栈指针的四字节边界，并且我们可以使用多个四字节 POP 来到达它。

## 3.4 任意内存覆盖

漏洞利用的圣杯就是控制进程的指令指针。在多数情况下，指令指针（通常命名为 IP，或者 PC）是一个 CPU 中的寄存器，并不能直接修改，因为只有机器指令可以修改它。但是如果我们能够改动机器指令，我们就已经控制了它。所以我们不能直接控制进程。通常，进程比起当前的攻击者拥有更多的权限。

反之，我们需要寻找修改指令指针的指令，并且影响这些指令修改它的方式。这听起来很复杂，但是多数情况下这非常简单，因为有些指令从内存获取指令指针，并且跳到那里。所以在多数情况下，控制了这部分内存，其中储存了指令指针，就控制了指令指针本身。这就是多数缓冲区溢出的工作方式。

在两阶段的过程中，首先要覆盖保存的指令指针，之后程序会指令一个合法的指令，它将控制流转移到攻击者提供的地址中。

我们会检测一些不同的方式，使用格式化字符串漏洞来完成它。

### 3.4.1 利用 - 类似于常见的缓冲区溢出

格式化字符和村啊漏洞有时提供了一个在缓冲区长度周围的方式，并且和常见的缓冲区溢出的利用方式相似。这是出现在 QPOP 2.53 和 bftpd 中的代码：

```c
char outbuf[512]; 
char buffer[512];

sprintf (buffer, "ERR Wrong command: %400s", user); 
sprintf (outbuf, buffer);
```

这种例子通常深藏在真实的代码中，并且不会那么明显，就像上面的例子那样。通过提供一个特殊的格式化字符串，我们就能够绕过`%400s`的限制：

```
"%497d\x3c\xd3\xff\xbf<nops><shellcode>"
```

任何东西都和常见的缓冲区溢出类似，只是开头 -- `%497d` -- 不同。在常见的缓冲区溢出中，我们覆盖了函数帧在栈上的返回地址。在拥有该帧的函数返回值，它会返回到我们提供的地址。地址指向`<nop>`中的某个地方。有一些不错的文章，描述了这一利用方式，并且如果这个例子对于你来说还不够清楚，你应该考虑首先阅读一篇入门文章，就像 [5] 那样。

它创建了长度为 497 的字符串。再加上错误信息（`ERR Wrong command: `），它超出了`outbuf`缓冲区四个字节。虽然`user`字符串只允许为 400 字节，我们可以通过不当使用格式化字符串参数来突破这个长度。由于第二个`sprintf`不检查其长度，它可以用于突破`output`的边界。现在我们写入一个返回地址`0xbfffd33c`，并且使用已知的旧办法来利用它，就像我们在任何缓冲区溢出中所做的那样。虽然任何允许拉伸的格式化参数都这样，例如`%50d`，`%50f`或者`%50s`，我们还是应该选择一个不会提领指令或者可能导致除零错误的参数。这就排除了`%50f`和`%50s`。我们只剩下了整数输出参数：`%u`、`%d`和`%x`。

GNU C 库包含一个 Bug，如果你使用 n 大于 1000 的`%nd`参数，它会导致崩溃。这是一种判断远程 GNU C 库的方式。如果你使用`%.nd`，它正产工作，除非你用了很大的值。有关这个长度的深入讨论，请见门户网站的文章 [3]。

### 3.4.2 利用 - 只通过格式化字符串

如果我们不能使用刚刚提到的简单的利用方式，我们仍旧可以利用这个过程。由此，我们可以扩展我们极其有限的控制 -- 控制格式化函数的能力 -- 到真实的执行流控制，它会执行我们的原始机器码。看看这段代码，它在 wu-ftpd 2.6.0 中发现。

```c
char buffer[512];

snprintf (buffer, sizeof (buffer), user); 
buffer[sizeof (buffer) - 1] = ’\0’;
```

在上面的代码中，我们不能通过插入某些“拉伸”格式参数来扩大缓冲去，因为程序使用了安全的`snprintf`函数来确保我们不能突破`buffer`。最开始它像是，我们不能做很多有用的事情，除了使程序崩溃，并且窥探到一些内存。

让我们回忆提到过的格式化参数。`%n`参数将已经打印的字节数，写入到我们所选的变量中。通过将整数指针放置到栈上作为参数，变量地址被提供给格式化函数。
